\documentclass{article}
\usepackage{tabularx}
\title{The Pragmatic Programmer}
\author{Grayson Wills}
\begin{document}
\maketitle
Notes and excerpts from *The Pragmatic Programmer*.

\section*{Goals for Consistent Learning}
\begin{enumerate}
    \item Learn AT LEAST one new language every year
        \begin{itemize}
            \item It's incredibly important for you to diversify your skills and attempts to really comprehend the inner workings of several different languages, their limitations, and why they work so well in the environments they were built for.
        \end{itemize}
    \item Read a technical book every month
        \begin{itemize}
            \item You've already started doing this by reading this book! Audio books are also a great resource, and the sorts of technical books that work well for audio books are those that don't necessarily code, but emphasize specific traits and qualities. "How Google Works" is a great example of this!
        \end{itemize}
    \item Read non-technical books each month
        \begin{itemize}
            \item You've been doing this your whole life! You LOVE to read, especially those Stephen King books. You've been branching out recently into the more psychology type of stuff, which is totally fine! So long as you continue learning and growing, you're doing something to keep yourself active!
        \end{itemize}
    \item Take Classes
        \begin{itemize}
            \item As of writing this in summer 2025, this is not a difficult task... You're taking two classes a semester including summers, plus some other courses from places like Udemy and Scrimba. Honesltly, if you would've focused up this much in college, you would've been muuuuch further along by now. BUT, that doesn't matter... Everyone has their own path, and this has been yours. No need to dwell on that past, just on the future!
        \end{itemize}
    \item Participate in local groups and meetups
        \begin{itemize}
            \item This is something you struggle with. In college, you were a part of SOOO many groups, but didn't quite meaningfully contribute to any of them besides Spikeball and the Texas SpaceCraft Lab. If you would've put in some extra work and taken yourself away from trying to do everything all at once, you probably could've learned more. But, that's what college is all about! It would probably be good to get involved in a MakerSpace of something after work hours, and just see what happens. There's one literally down the street from you... might be time to get involved in that?
        \end{itemize}
    \item Experiment with Different Environments
        \begin{itemize}
            \item This is really talking about different IDE's, living spaces, OS environments, etc. You've done a better job at this recently, getting a MAC and a raspberry pi for linux based stuff, and you actually use a variety of IDE's. I'm sure there's other paths to go down in terms of this, but for now I think that you're doing this pretty good!
        \end{itemize}
    \item Stay Current
        \begin{itemize}
            \item This is also something you have been doing much better about, although admittedly you could be doing more. Newsletters, reading engineering blogs from different companies, etc, instead of just LinkedIn being your source would be a way better idea. However, with so much knowledge to consume, it would be difficult to stay on top of things, which is why I've toyed with the idea of building an LLM to scrape the internet for new things and give a summary of what I want, then I can go and find something that I want to read that day.
        \end{itemize}
\end{enumerate}

\section*{Tips From The Book:}
\begin{enumerate}
    \item Care About Your Craft
    \item Think About Your Work
    \item You Have Agency
        \begin{enumerate}
            \item Basically, you can change your environment. Don't do things that you hate
        \end{enumerate}
    \item Provide Options, Don't Make Excuses
    \item Don't Leave Broken Windows
        \begin{enumerate}

            \item It is YOUR job to keep the code maintainable, clean, and easy to change, just as it is everyone else's. Don't leave it around, else entropy will surely find your project and eat it alive
        \end{enumerate}
    \item Be a Catalyst For Change
        \begin{enumerate}
            \item It is YOUR job to be the change that you want to see. If something goes wrong, take responsibility. If something goes right, take responsibility. Either way, be the driving force behing forward progress, not meaningless spiraling
        \end{enumerate}
    \item Remember the Big Picture
    \item Make Quality a Requirements Issue
    \item Invest Regularly in Your Knowledge Portfolio
    \item Critically Analyze What You Read and Hear
    \item English is Another Programming Language
        \begin{enumerate}
            \item Essentially, it is just as important for you to be as precise and methodical with the spoken word as you are with your programming language of choice. Precise and accurate language in this context helps achieve your goal
            \item It is possible to get your point across without a vast thesaurus of words in your brain. Pictures and words can operate just as well, but you still need to share the same language as everyone else. Learn the terminology, then you can really get into the meat and potatoes of how things work
        \end{enumerate}
    \item It's What You Say and the Way You Say It
    \item Build Documentation, Don't Bolt It On
        \begin{enumerate}
            \item Your code IS documentation, if written well... so write it well!
        \end{enumerate}
    \item Good Design Is Easier to Change than Bad Design
    \item Don't Repeat Yourself
    \item Make It Easy To Reuse
    \item Eliminate Effects Betwen Unrelated Things
        \begin{enumerate}
            \item Reduce Coupling as Much as Possible
        \end{enumerate}
    \item There Are No Final Decisions
    \item Forgo Following Fads
    \item Use Tracer Bullets To Find Targets
        \begin{enumerate}
            \item Tracer Bullets are bullets specially made for military to see feedback on their shot in real time: they leave trails of smoke on their way to a target
            \item In the same way, your code should be a tracer for portions of a project that point the path and leave a trail to how you got to the current stage.
            \item This code should also be easy to change
            \item It is recommended that Tracer code be built to connect parts of a project that you might not be sure how to connect, such as syncing a frontend and a backend. Once that tracer code works, you can refactor and continue expanding on the project from there, fleshing out individual systems rather than focusing on the connection between the systems. This way, you no longer have to focus on building out the system end-to-end, but piece-by-piece
        \end{enumerate}
    \item Prototype to Learn
    \item Program Close To The Problem Domain
    \item Estimate To Avoid Surprises
    \item Iterate the Schedule with the Code
    \item Keep Knowledge in Plain Text
    \item Use the Power Of Command Shells
    \item Achieve Editor Fluency
    \item Always Use Version Control
    \item Fix the Problem, Not the Blame
        \begin{enumerate}
            \item Don't put a band-aid on the problem, find the root cause and fix it
        \end{enumerate}
    \item Don't Panic
    \item Failing Test Before Fixing Code
        \begin{enumerate}
            \item You should write your tests BEFORE you write your Code
            \item Don't get test happy... that's a poor decision. You don't need to test if a class exists, just test for if it has the functionality that you think it does
            \item The book outlines that if you start designing your tests first, you almost guarantee yourself to write the minimum amount of code possible to pass that test. If you need to flesh it out later with additions based on future code, you can!
        \end{enumerate}
    \item Read The Damn Error Message
    \item "select" Isn't Broken
        \begin{enumerate}
            \item Chances are, the OS isn't broken, the framework doesn't have a bug, and your language of choice works fine, you're just using it wrong
            \item Take a step back and see what happens when you actually look into what the function does
        \end{enumerate}
    \item Don't Assume, Prove It
    \item Learn A Text Manipulation Language
        \begin{enumerate}
            \item Perl
            \item emacs
            \item bash
            \item awk
        \end{enumerate}
    \item You Can't Write Perfect Software
    \item Design With Contracts
        \begin{enumerate}
            \item You shouldn't be doing multiple mutations of data inside of a method. 
            \item If you want to edit data, make sure the data meets the requirements that the data needs to pass through the function without issue
        \end{enumerate}
    \item Crash Early
        \begin{enumerate}
            \item If you crash, you know that you have a problem
            \item Something interesting is that they say you should leave your assertions in the program. That way you can know EXACTLY where the program crashed... how interesting
        \end{enumerate}
        \item Use Assertions To Prevent the Impossible
    \item Finish What You Start
        \begin{enumerate}
            \item The same function that allocates a resource should also deallocate it
        \end{enumerate}
    \item Act Locally
    \item Take Small Steps... Always
    \item Avoid Fortune Telling
        \begin{enumerate}
            \item Don't count on tomorrow looking like today. Business needs change all the time, and your code could look INSANELY different. Be flexible, be ready for change, which is why it's even more important for your code to be the same way
        \end{enumerate}
    \item Decoupled Code Is Easier To Change
    \item Tell, Don't Ask
        \begin{enumerate}
            \item Don't make decisions based on the internal state of an object, then update that object. BAAAD idea
        \end{enumerate}
    \item Don't Chain Method Calls
    \item Avoid Global Data
    \item If It's Important Enough To Be Global, Wrap It in an API
    \item Programming is about Code, Programs are About Data
    \item Don't Hoard the State, Pass it Around
        \begin{enumerate}
            \item Data is a flowing river. It is meant to be passed around. Don't tie it to a particular group of functions
        \end{enumerate}
    \item Don't Pay Inheritance Tax
        \begin{enumerate}
            \item Inheritance has it's downfalls... You pass methods and variables down to other classes, and changing them has a cascading effect downwards
            \item Multiple Inheritance can eventually lead to bigger issues if done incorrectly
            \item Interfaces, Delegations, or Mixins/traits will be better alternatives
            \item Inheritance can be used as a last resort
        \end{enumerate}
    \item Prefer Interfaces To Express Polymorphism
    \item Delegate To Services
        \begin{enumerate}
            \item Services are useful ways to implement functions across multiple spaces without delegating them to the class itself. 
            \item A good example is Angular Web Development: You can literally have a service for anything. It just helps to separate the function from the class where possible if you're going to have multiple places where a function is being called
        \end{enumerate}
    \item Use Mixins to Share Functionality
    \item Parameterize Your App Using External Configuration
    \item Analyze Workflow to Improve Concurrency
        \begin{enumerate}
            \item Most of the time, nothing that you do has to be done at the same time. 
            \item This is most prevalent in today's day and age, when data is at an all time high and needs to be processed efficiently
        \end{enumerate}
    \item Shared State is Incorrect State
    \item Random Failures are Often Concurrency Issues
    \item Use Actors For Concurrency Without Shared State
        \begin{enumerate}
            \item Actor: Individual virtual processor with its own private state. Each one has a mailbox and kicks into life when the mailbox has anything. Can create other actors
            \item Process: a more general purpose virtual processor implemented by the OS
        \end{enumerate}
    \item Use BlackBoards to Coordinate Workflow
        \begin{enumerate}
            \item When the order of information doesn't matter, a blackboard system is GREAT instead of using threads with a shared state
        \end{enumerate}
    \item Listen to Your Inner Lizard
        \begin{enumerate}
            \item Your instincts aren't necessarily correct, but there's a reason that they are kicking in. Try to understand what's happening and what they're saying, and you'll be better off for it down the line.
        \end{enumerate}
    \item Don't Program by Coincidence
        \begin{enumerate}
            \item There are many developers that code bit by bit, get it to work, but don't understand why it's working. DO NOT DO THIS. 
            \item This is becoming more commonplace in a world where the barrier to entry for normal people is getting lower: people use AI to solve their problems, but they don't understand why the solution works, so they don't know how to fix it
        \end{enumerate}
    \item Estimate the Order of Your Algorithms
    \item Test the Order of Your Estimates
    \item Refactor Early, Refactor Often
        \begin{enumerate}
            \item You should refactor when you learn something new! That's all the time!
        \end{enumerate}
    \item Testing is Not About Finding Bugs
    \item A Test Is The First User of Your Code
    \item Build End-to-End, Not Top-Down or Bottom Up
    \item Design to Test
    \item Test Your Software or Your Users Wills
    \item Use Property Based tests to Validate Your Assumptions
    \item Keep It Simple and Minimize Attack Surfaces
    \item Apply Security Patches Quickly
    \item Name Well; Rename When Needed
    \item No One Knows Exactly What They Want
    \item Programmers Help People Understand What They Want
    \item Requirements Are Learned In A Feedback Loop
    \item Work with a User to Think Like a User
    \item Policy is Metadata
    \item Use a Project Glossary
    \item Don't Think Outside the Box - Find the Box
    \item Don't Go into the Code Alone
    \item Agile is Not a Noun, Agile is How You Do Things
    \item Maintain Small, Stable Teams
    \item Schedule It to Make It Happen
    \item Organize Fully Functional Teams
    \item Do What Works, Not What's Fashionable
    \item Deliver When Users Need It
    \item Use Version Control to Drive Builds, Tests, and Releases
    \item Test Early, Test Often, Test Automatically
    \item Coding Ain't Done 'Til All The Tests Run
    \item Use Saboteurs to Test Your Testing
    \item Test State Coverage, Not Code Coverage
    \item Find Bugs Once
    \item Don't Use Manual Procedures
    \item Delight Users, Don't Just Deliver Code
    \item Sign Your Work
    \item Do No Harm
    \item Don't Enable Scumbags
    \item Have Fun!
\end{enumerate}

\section*{Quotes}
    \begin{tabularx}{0.8\textwidth} { 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X 
  |  >{\centering\arraybackslash}X |}
    \hline
    
    Quote & Author & Source\\
    
    \hline
    
    'When I use a word,' Humpty Dumpty said, in rather a scornful tone, 'it means ust what I choose it to mean-neither more or less 
    & Lewis Caroll 
    & Through The Looking Glass \\
    
    \hline

    I'm not in this world to live up to your expectations and you're not in this world to live up to mine
    & Bruce Lee
    & Unknown\\

    \hline

    The Greates of all weaknesses is the fear of appearing weak 
    & J.B.Bossuet
    & Politics from Holy Writ, 1709\\

    \hline

    Striving to better, oft we mar what's well.
    & Shakespeare
    & King Lear 1.4\\

    \hline

    An investment in knowledge always pays the best interest
    & Ben Franklin
    & Unknown \\

    \hline

    I believe that it is better to be looked over than it is to be overlooked.
    & Mae West
    & Belle of the Nineties, 1934 \\

    \hline

    Nothing is more dangerous than an idea if it's the only one you have 
    & Emil-Auguste Chartier (Alain)
    & Propos sur la religion, 1938 \\

    \hline

    Ready, fire, aim...
    & Anon
    & Unknown \\

    \hline

    Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it.
    & George Santayana
    & Life of Reason\\

    \hline

    It is a painful thing to look at your own trouble and know that you yourself and no one else has made it 
    & Sophocles 
    & Ajax \\

    \hline

    The easiest person to deceive is one's self 
    & Edward Bulwer-Lytton 
    & The Disowned \\

    \hline
  \end{tabularx}

    \begin{tabularx}{0.8\textwidth} { 
      | >{\centering\arraybackslash}X 
      | >{\centering\arraybackslash}X 
      |  >{\centering\arraybackslash}X |}
        \hline
        Nothing astonishes men so much as common sense and plain dealing
        & Ralph Waldo Emerson
        & Essays \\
    
        \hline
    
        There is a luxury in self-reproach. When we blame ourselves we feel no one else has a right to blame us
        & Oscar Wilde
        & The Picture of Dorian Gray \\
    
        \hline
    
        To light a candle is to cast a shadow
        & Ursula K. Le Gui
        & A Wizard of Earthsea\\
    
        \hline
    
        It's tough to make predictions, especially about the future.
        & Lawrence "Yogi" Berra
        & from a Danish Proverb\\
    
        \hline
    
        When we try to pick out anything by itself, we find it hitched to everything else in the Universe
        & John Muir
        &My First Summer in the Sierra \\
    
        \hline
    
        Things don't just happen; they are made to happen
        & John F. Kennedy
        & JFK\\
    
        \hline
    
        If you can't describe what you are doing as a process, you don't know what you're doing
        & W. Edwards Deming
        & Unknown\\
    
        \hline
    
        You wanted a banana but what you got was a gorilla holding the banana and the entire jungle
        & Joe Armstrong 
        & Unknown\\
    
        \hline
    
        Let all your things have their places; let each part of your business have its time
        & Benjamin Frnaklin
        & Thirteen Virtues (AutoBiography) \\
    
        \hline
    \end{tabularx}

    \begin{tabularx}{0.8\textwidth} { 
        | >{\centering\arraybackslash}X 
        | >{\centering\arraybackslash}X 
        |  >{\centering\arraybackslash}X |}
        
        \hline

        Without writers, stories would not be written, without actors, stories could not be brought to life
        & Angie-Marie Delsante
        & Unknown \\

        \hline

        The writing is on the wall 
        & Daniel 5 
        & Unknown \\

        \hline

        Only human beings can look directly at something, have all the information they need to make an accurate prediction, perhaps even momentarily make the accurate prediction, and then say that it isn't so
        & Gvain de Becker
        & The Gift of Fear
        \\

        \hline

        Good fences make good neighbors 
        & Robert Frost
        &Mending Wall \\

        \hline

        The beginning of wisdom is to call things by their proper name
        & Confucius
        & Unknown
        \\

        \hline

        Perfections is achieved, not when there is nothing left to add, but when there is nothing left to take away
        & Antoine de St Exupery
        & Wind, Sand, and Starts, 1939 \\

        \hline

        I've never met a human being who would want to read 17,000 pages of documentation, and if there was, I'd kill him to get him out of the gene pool.
        & Joseph Costello
        & President of Cadence 
        \\

        \hline
    
        \hline
    \end{tabularx}

    \begin{tabularx}{0.8\textwidth}{
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X |}
    \hline

    You keep using that word. I do not think it means what you think it means
    & Inigo Montoya
    & The Princess Bride \\

    \hline

    At Group L, Stoffel oversses six first-rate programmers, a amnagerial challenge roughly comparable to herding cats
    & The Washington Post
    & June 9, 1985 \\

    \hline

    Civilization advances by extending the number of important operations we can perform without thinking
    & Alfred North Whitehead
    & Unknown \\

    \hline

    When you enchant people, your goal is not to make money from them or to get them to do what you want, but to fill them with great delight
    & Guy Kawasaki
    & Unknown \\

    \hline

    You have delighted us long enough
    & Jane Austin
    & Pride and Prejudice \\

    \hline
    \end{tabularx}

\section{It's Your Life}
    \paragraph{Summary}
    Work How You Work Best! So long as you have good knowledge and skillset, there's not much reason for you to work in a way that is uncomfortable to you or that discourages active thought. Do things that you want to do, so long as it is done ethically and in the service of good

\section{The Cat Ate My Source Code}
    \paragraph{Summary}
    It is your job to maintain integrity above all else. You are responsible for your code, and not meant to fork blame over to people or circumstances that are not actually the problem.

\section{Software Entorpy}
    \paragraph{Summary}
    Things have a tendancy to spiral out of control really fast. There is this proclivity to allow the disorganized nature of things become more disorganized. Their "broken window" theory speaks to this very well. An untouched car in the middle of SF will get no attention, but the moment \textbf{ONE} window breaks, the rest start breaking in exponentially faster rates.

\section{Stone Soup and Boiled Frogs}
    \paragraph{Summary}
    They tell a fable about three soldiers that fool a town into helping prepare real soup. It's just as easy to trick a group of people into all contributing to a project that you believe is good for the team, just as it is to allow things to become slowly dysfunctional. The concept of the boiled frog is also introduced. If a frog is put into an already boiling pot, or the pot is heated up too quickly, the the frog will jump out. Alternatively, the frog will not jump out of the pot if you slowly heat it up

\section{Good-Enough Software}
    \paragraph{Summary}
    Quality should be mandatory. You are an artist painting a mural with your code. However, every artist has to take a step back from their art and know when it it "good enough" for now. You can never write the perfect code EVER. Don't try to

\section{Your Knowledge Portfolio}
    \paragraph{Summary}
    Our knowledge portfolio should be ever expanding, and not a moment of our time wasted. Don't let any moment go without you learning something at some point. It is an unfortunate circumstance that there is so much knowledge at our disposal and yet we waste so much time doing so many menial things. This is also where the concept of increasing your knowledge portfolio is introduced, and those concepts are at the start of this paper. We also introduce "Asking the 5 Why's" to help understand why something occurs.

\section{Communicate!}
    \paragraph{Summary}
    Being a good communicator is an essential part of being a good software engineer. There are many different forms of communication, and it is not imperative that you are fluent in everything, but you should be fluent in a few. Your spoken language of choice should be one of these. Documentation should be another. Communicating through comments and code is also something that should be emphasized, since there will be points in time where you come into contact with pieces of information that other people may not intuitively understand, and thus you need to emphasize your point

\section{The Essence of Good Design}
    \paragraph{Summary}
    Make your code easy to change. That's really all this section is about.

\section{DRY-The Evils of Duplication}
    \paragraph{Summary}
    Duplication is said that it should never happen in your code. However, the concepts that come about this aren't always as obvious as this rule may seem. Not all code is duplication. Some places contain different kinds of knowledge, and so similar code that could be made into one function might not actually count for the DRY principle. However, you still tend to replicate code that has already been made by 
    \begin{enumerate}
        \item Trying to recreate portions of code that already exist in libraries and API's
        \item Newer team members reimplementing existing functions
    \end{enumerate}
    So, it is your job to keep things clean an organized, across your ENTIRE project. That means your frontend and backend services aren't doing the same data validation, stuff like that

\section{Orthogonality}
    \paragraph{Summary}
    Orthogonality is a geometry concept discussing how two lines interact and but do not completely effect each other, i.e the removal of one line does not impact the function of the other line. In a similar way, your code should be orthogonal, meaning that you shouldn't need to do a full refactor of your entire codebase if you take out a service. Keeping your code decoupled and avoiding global data is essential to building orthogonal systems. Part of this includes using resources that are non-volatile in terms of change.
    \subsection*{An Example of An Orthogonal System}
    A helicopter: trying to change the speed of the rotor will effect the height, but you also need to adjust the pitch and the yaw of the back rotor to properly calibrate. When one system changes, all of them change. Don't be a helicopter. Avoid this at all costs.
    
\section{Reversibility}
    \paragraph{Summary}
    The needs of a business and the cost effectiveness of certain tools are ALWAYS subject to change. Do everything in your power to utilize architecture that is solid and flexible, as well as building systems independent of each other. Make decisions that are able to be reversed, because they will bite you in the ass later down the line. Also, do not follow industry fads or trends, because hype trains usually go so fast that they derail VERY quickly.

\section{Tracer Bullets}
    \paragraph{Summary}
    Tracer Bullets are incredibly useful for a variety of reasons, but for code, it's a great way for you to integrate different parts of your system into each other and attempt to get a bunch of the pieces together. It's quick, it's dirty and it's also a reason to get to your users early. It also gives you a better feel for your progress. However, this is not the equivalent of a prototype. Prototypes are meant to be representations of the full product, not some wild bullet that probably didn't hit it's mark.

\section{Prototypes and Post-it Notes}
    \paragraph{Summary} Prototypes are really good for quickly building up mockups of the finished product, and can be readily available for people to test. For these purposes, use languages that are easy to use, such as Python or Ruby, when creating these applications, as you plan to throw the prototype away anyway. You should really be prototyping to learn things, not to keep a product.

\section{Domain Languages}
    \paragraph{Summary} Domain languages are good for a couple types of problems. These are made for VERY specific tasks. Things like cucumber, Ansible, or Phoenix are examples of these. YAML and JSON are also other forms. For the most part, you don't have to make your own domain language, but it is encouraged to know how if you ever need the use case.

\section{Estimates}
    \paragraph{Summary} At the end of the day, the best thing to say is \textit{I'll get back to you}. Estimating is a skill in it of itself... knowing how much data, or how many servers, or how much time is going to take is something that comes with experience. Avoid giving several numbers if possible, since saying something along the lines of \textit{20, 30 hours if you're going to give me buffer} is more confusing than it is helpful.

\section{The Power of Plain Text}
    \paragraph{Summary} Plain text is a universal language that is commonly used in the Computer Science world. HTML, JSON, YAML, whatever it is that you think acts as kind of a "markup" language is probably plain text. These are easy to search through and easy to find information. Take Unix for example. Everything in there is stored in plain text, there is no if's and's or but's about it. It's pretty simple and straightforward: When in doubt, plain text it out.

\section{Shell Games}
    \paragraph{Summary} The shell is where the highest amount of productivity is found. If you learn your shell commands, the productivity soars because typing on a keyboard is way faster than trying to accurately click around with a mouse. Even better, modifying your shell by creating your own custom commands/snippets that you often use is an even better way to get to the places you want to go, and FAST

\section{Fluency}
    \paragraph{Summary} By their definition, fluency is the ability to navigate around your IDE without using your mouse. After trying this out for a couple weeks, I completely agree. In fact, the only way to achieve true fluency is to ONLY be using the keyboard in most circumstances, and a mouse whenever else. This is something that is going to take practice and patience in the best of times, but it's going to be completely necessary in the coming years when you are really trying to crank out high level projects at rapid speed. There's not going to be time for thinking, just reacting. Same as with your Spikeball... at this point, it's just a dance, so natural to you that you've become one with the 360 game. The same should happen with your coding. The machine needs to become an extension of your hands. They also encourage to create extensions whenever you need to, or find extensions that fix the problems that you have.

\section{Version Control}
    \paragraph{Summary} Version Control is our gift from the engineering gods to let us undo any mistake we have ever made and beg for forgiveness. On good teams, this is a vital tool to allow to rollback to previous versions of a working project, or undo a commit that someone fat fingered and broke the entire thing. Now, here's the thing, shared directories are NOT version control. Having a shared directory in a local file system is tedious and unruly, and having one doesn't have branches that people can independently work on or do individual testing. Sure, you might be able to roll some things back if the internal system has a file history system like a Windows machine, but you're better off using something that hasn't been developed by your own team. Good version control software has multiple functions besides just version control, such as Kanban boards for project stories and AGILE methodology.

\section{Debugging}
    \paragraph{Summary} Debugging is an art in it of itself. There's really only one real way to do it as well: with a cool clear head and an aptitude for fixing something. Something to keep in mind that is a good practice is creating tests that fail on purpose to prove that your assumptions about any sort of data are correct. You should be able to prove your assumptions are accurate. Debugging also comes from talking to your users! Say there is a user experiencing an issue, and you are "replicating the issue" but not getting an error, then there's something that you are missing. Go to your user and have them do it right in front of you. That way you can know the exact steps. Language is a low bandwidth for of communciation, action is better. Also... read the damn error message. Most of the time error messages nowadays are pretty verbose in their writing, and the source cause is actually pretty accurate nowadays compared to a couple of years ago. Let the error message guide you to the solution. On top of ALL of this... the issue with the code probably isn't a function in it of itself, but your understanding of it. "select" isn't broken is a phrase that is referred to when an engineer claims his Linux OS is broken, but then realizes that the way he is using select is inherently flawed. Don't be that guy. Look into how things are working, and understand them in their entirety.

\section{Text Manipulation}
    \paragraph{Summary} Text manipulation can be difficult to master but once achieved make certain aspects of the job much easier. The authors of this book used a combination of Ruby and Python to update and manipulate different versions of this book, as they can have a text version, an online version, and other such versions have have strange little nuances into how they show up. 

\section{Engineering Daybook}
    \paragraph{Summary} Daybooks are a great way to keep track of little nuances about your day and pieces of information that you want to remember. You've learned the hard way that you're not going to remember everything all at once, because your brain wants to store things in there like muscle memory and deep insights from experiences, not trivial facts about why you chose to write that piece of code in that particular fashion. It's exhausting to try and rememeber everything, and the smartest people in the world don't try either! They write all the trivial stuff down so that they can focus on the actual thinking behind things. Don't try and be a hero... you're not better than anyone, you're not some crazy savant, you're a human being just like the rest of them, and in order for you to operate on a different level you need to start clearing your mind up for that kind of thinking!

\section{Design by Contract}
    \paragraph{Summary} Design by contract is the method that is taken to create a function or method that executes good data and good data only. Essentially, when you are calling a method, it is in your best interests to make sure your worldview about the conditions before and after you call the function are the same that you think they are.

\section{Dead Programs Tell No Lies}
    \paragraph{Summary} Allow your programs to die so that you can collect the proper data from them. It's pretty important for you to know what's going on with your programs and why they might be crashing. But, instead of doing a bunch of log messages, you can either write some asserts to prove that the intended funcionatlity exists OR just let it die and see where it happened.

\section{Assertions}
    \paragraph{Summary} This chapter gives a case as to why you should leave assertions in your code, even when deploying to a production environment. Assertions are meant to check if the reality that you believe to be true is occuring, preventing your program from continuing onwards indefinitely until it crashes. Logging messages can lie... those logs that you are looking at could be occurring long after the problem actually happens further upstream. If you assert during critical points, such as before and after a method executes, you guarantee the behavior that you are looking for.

\section{How To Balance Resources}
    \paragraph{Summary} This section mainly talks about good practices when opening and closing resources, mainly reading and writing files, how to open and close them, and where to close based on where you opened. It is a tricky subject, since you're never guaranteed to reach your close statement, and so you have to write it in try-catch statements in order to conceivably get to the desintation that you are looking for 

\section{Don't Outrun Your Headlights}
    \paragraph{Summary} \textit{Don't Outrun Your Headlights} is a phrase synonymous with crashing into something or driving off a road in the dark: you're going to fast to be able to react to what's right in front of you. It's a scary thing, and in order to avoid any disaster in pitch black, you need to match a speed so that you can quickly react without being in danger. This is the equivalent for the programmer as well; take small steps to avoid disaster. Prediction of the future is one of the hardest things in the world to accomplish, and if you try to do such a thing, chances are you will run yourself off the cliff in the long run.

\section{Decoupling}
    \paragraph{Summary} Decoupling code is a job in itself sometimes. Keeping it all separated comes in many forms. Here are a couple: Ask, Don't Tell is one of their mottos for when you should only insert data into a method that is clean. They would rather you don't chain method calls, as those methods are subject to change themselves, and using the chaining rules like in Java can cause some nasty side effects. Additionally, removing globalization i.e don't use global variables ever. You can wrap them in a an API or service if you really want to, but there's very little reason to make something global.

\section{Juggling the Real World}
    \paragraph{Summary} There are several ways to juggle the async world that is production, and many methods are suggested here: events, Finite State Machines (FSM), Publisher-Subscriber i.e pubsub, and in the world of the web, Observables aka reactive programming. events are as simple as button clicks, and can be fed into all of these other methods to similitude a fluid dynamic environment. It would be useful to become a little more familiar with the FSM and pubsub methods, as they are (as of writing this) a little foggy in implementation. However, the Observables are something that I am mildly comfortable with, so I think it's best for now not to focus on those as much when practicing my coding ability.

\section{Transforming Programming}
    \paragraph{Summary} A simple premise is introduced here: Programming is about code, programs are about data. Transformational programming is seen as a way to transform data in order to ascertain a specific output. For example, the first problem set is asking how to find the best way to see the top 5 files with the most characters. We then see a terminal input command with several pipes that feed information through to the end in order to find the files. Essentially, transformational programming is piping information in a coherent way to a designate goal. It's a series of nested transformations that is meant to simplify your code and make it easier to read in the long run.

\section{Inheritance Tax}
    \paragraph{Summary} Inheritance doesn't really seem to be a reliable answer in most cases, and here's why. Inheritance tends to make code immensely coupled, especially for languages like Python that allow for multiple inheritance OR for multiple subclassing down long roads. There are a couple ways to skirt around this without immensely coupling your code: interfaces, API's/services, and mixins. Interfaces allow for polymorphism without inheritance, API's allow you to store information off board the class itself, and mixins help merge existing functionalities with new functionalities. Do everything in your power to avoid actual inheritance like the plague, because changing one command, variable name, or method will screw you to no avail.

\section{Configuration}
    \paragraph{Summary} You need external configuration files for values that may change after the application has gone live. This is the equivalent of Secrets in your database or on Github when you're doing your actions. Whatever it is that you may need to go live without other people seeing it, chances are you will need this. This also includes license keys.

\section{Breaking Temporal Coupling}
    \paragraph{Summary} Many programmers get stuck because they have difficulty thinking about things in non-linear time. Not everything in your program needs to be done at the same time, just like a bartender does not have to make pina coladas in one go. In fact, if you did end up making pina coladas in a linear fashion, that man would be fired on the spot. You should draw an activity diagram to determine what can be done at the same time and what can't.

\section{Shared State is Incorrect State}
    \paragraph{Summary} This section outlines the flaws of concurrency when attempting to access the same resource. Now, there are ways around this, like semaphores or mutexes, but there are still issues with when to claim the lock and when to release. Some languages take care of this for you, but typically this isn't a good idea if one of the threads fails and remains holding onto the lock. This becomes increasingly difficult the more resources that are in a shared state. This is why there are other methods encourages that will be outlined momentarily.

\section{Actors and Processes}
    \paragraph{Summary} Actors/Processes are a provided substitution for the threading locks/semaphores issues. Actors are implementors of different tasks, and are dead when their inbox is empty, then come alive when they have a message. It is a pretty simple implementation, but very powerful to avoiding the issues with a shared state. In this context, processes are also considered actors. Actors work equally well on all different architectures, from multi-cores to single cores.

\section{Blackboards}
        \paragraph{Summary} Blackboards are a basic way for multiple actors to perform a shared state analysis if you really need shared state. The thing about blackboards is that ANYTHING can go on them, and ANYONE can view the information on the blackboard. So in essence, you can get through a ton of information without having to worry about the order things are placed in, and you can put anything on the blackboard without worrying that your inclusion will effect the rest of the information. This comes at a cost since a lot of the action is indirect, so it's hard to keep track of all the moving parts associated with such a system.

\section{Listen to Your Lizard Brain}
    \paragraph{Summary} Your instincts tend to be the things that take you the furthest. If something feels wrong, chances are something might be wrong. But sometimes those instincts try to take a little bit more of the steering wheel than they are supposed to. For instance, when you are prototyping, it is not your job to create the perfect code, but your brain keeps telling you to refactor. Learn to talk yourself down from those heights and speak to your lizard brain, either by going on a walk, rubber ducking it, or writing a sticky note.

\section{Programming by Coincidence}
    \paragraph{Summary} Don't be the guy that just makes things up as he goes. This kind of programmer is becoming more and more prevalent as the years go on due to the rise of AI coding. It's going to be so easy in the next few years to be exceptional, so learn to do things the right way and you're going to be soaring to new heights!
\end{document}
